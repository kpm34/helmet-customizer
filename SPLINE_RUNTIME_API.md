# Spline Runtime API Reference

Documentation for Spline Runtime naming conventions, API patterns, and differences from conventional 3D software (Three.js, Blender).

**Purpose:** Bridge the gap between Spline's native API and standard 3D development conventions.

---

## Version Information

- **Spline Runtime Version:** 1.9.98 (from package.json)
- **Three.js Version:** 0.181.1
- **Documentation Date:** 2025-11-16

---

## React Integration

### Next.js with Server Side Rendering

Spline provides SSR support for Next.js with automatic placeholder generation.

**Standard Client-Side Rendering:**
```typescript
import Spline from '@splinetool/react-spline';

export default function App() {
  return (
    <div>
      <Spline scene="https://prod.spline.design/KFonZGtsoUXP-qx7/scene.splinecode" />
    </div>
  );
}
```

**Next.js with SSR + Blurred Placeholder:**
```typescript
import Spline from '@splinetool/react-spline/next';

export default function App() {
  return (
    <div>
      <Spline scene="https://prod.spline.design/KFonZGtsoUXP-qx7/scene.splinecode" />
    </div>
  );
}
```

**Key Differences:**
- **Client-only:** `@splinetool/react-spline` - No SSR
- **With SSR:** `@splinetool/react-spline/next` - Server renders autogenerated blurred placeholder

**Note:** Export as Next.js from the Spline editor to autogenerate the placeholder.

**Current Implementation (helmet-customizer):**
```typescript
// From app/page.tsx
import Spline from '@splinetool/react-spline';  // Client-side only

<Spline
  scene="/scene.splinecode"
  wasmPath="/"
  onLoad={onLoad}
/>
```

‚ö†Ô∏è **Potential Improvement:** Switch to `@splinetool/react-spline/next` for SSR placeholder support.

---

### Lazy Loading

To start loading react-spline **after** the whole website has finished loading, use lazy-loading. This improves initial page load performance by deferring the Spline component until needed.

**Technique:** Use `React.lazy()` with dynamic imports.

**Example:**
```typescript
import React, { Suspense } from 'react';

const Spline = React.lazy(() => import('@splinetool/react-spline'));

export default function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Spline scene="https://prod.spline.design/6Wq1Q7YGyM-iab9i/scene.splinecode" />
      </Suspense>
    </div>
  );
}
```

**Benefits:**
- Reduces initial bundle size
- Improves time-to-interactive (TTI)
- Spline loads only when component is rendered
- Custom loading state via `fallback` prop

**When to use:**
- Large Spline scenes (>1MB)
- Scenes below the fold
- Performance-critical applications
- Mobile-first designs

**Current Implementation (helmet-customizer):**
```typescript
// From app/page.tsx
import Spline from '@splinetool/react-spline';  // Direct import (not lazy)

// The Spline component loads immediately with the page
```

‚ö†Ô∏è **Potential Improvement:** Consider lazy-loading the Spline component if initial page load performance becomes a concern.

---

### Spline Component Props

Complete reference for all props you can pass to the `<Spline />` component.

| Prop | Type | Description |
|------|------|-------------|
| `scene` | `string` | Scene file URL or path |
| `onLoad?` | `(spline: Application) => void` | Called once the scene has loaded. The `spline` parameter is an instance of the Spline Application |
| `renderOnDemand?` | `boolean` | Whether or not to enable on demand rendering. Default: `true` |
| `className?` | `string` | CSS classes for the container |
| `style?` | `object` | CSS style object for the container |
| `id?` | `string` | Canvas id attribute |
| `ref?` | `React.Ref<HTMLDivElement>` | A ref pointing to div container element |
| `onSplineMouseDown?` | `(e: SplineEvent) => void` | Called when a Spline Mouse Down event is fired |
| `onSplineMouseHover?` | `(e: SplineEvent) => void` | Called when a Spline Mouse Hover event is fired |
| `onSplineMouseUp?` | `(e: SplineEvent) => void` | Called when a Spline Mouse Up event is fired |
| `onSplineKeyDown?` | `(e: SplineEvent) => void` | Called when a Spline Key Down event is fired |
| `onSplineKeyUp?` | `(e: SplineEvent) => void` | Called when a Spline Key Up event is fired |
| `onSplineStart?` | `(e: SplineEvent) => void` | Called when a Spline Start event is fired |
| `onSplineLookAt?` | `(e: SplineEvent) => void` | Called when a Spline Look At event is fired |
| `onSplineFollow?` | `(e: SplineEvent) => void` | Called when a Spline Follow event is fired |
| `onSplineScroll?` | `(e: SplineEvent) => void` | Called when a Spline Scroll event is fired |

**Example with Props:**
```typescript
<Spline
  scene="/scene.splinecode"
  renderOnDemand={true}
  className="w-full h-full"
  id="helmet-viewer"
  onLoad={handleLoad}
  onSplineMouseDown={handleMouseDown}
  onSplineMouseHover={handleMouseHover}
/>
```

**Current Implementation (helmet-customizer):**
```typescript
// From app/page.tsx
<Spline
  scene="/scene.splinecode"
  wasmPath="/"
  onLoad={onLoad}
/>
```

**Notes:**
- All event handlers receive a `SplineEvent` object with `e.target.name` containing the clicked object's name
- `renderOnDemand` optimizes performance by only rendering when changes occur
- The `onLoad` callback provides access to the `Application` instance for programmatic control

---

## Naming Conventions

### Transform Properties

#### Position
**Conventional 3D (Three.js):**
```javascript
mesh.position.x
mesh.position.y
mesh.position.z
```

**Spline Runtime:**
```javascript
// Same API as Three.js!
obj.position.x
obj.position.y
obj.position.z

// Example: Move object
obj.position.x += 10;
```

**Note:** Spline uses the same position API as Three.js - direct property access.

---

#### Scale
**Conventional 3D (Three.js):**
```javascript
mesh.scale.x
mesh.scale.y
mesh.scale.z
```

**Spline Runtime:**
```javascript
// Add Spline snippets here
```

---

#### Rotation
**Conventional 3D (Three.js):**
```javascript
mesh.rotation.x  // radians
mesh.rotation.y
mesh.rotation.z
```

**Spline Runtime:**
```javascript
// Add Spline snippets here
```

---

## Spline Application API Methods

The object exposed as the first argument of the `onLoad` function is a **Spline Application** instance. You can call these methods on it.

### Application Methods Reference

| Method | Type Signature | Description |
|--------|----------------|-------------|
| `emitEvent` | `(eventName: SplineEventName, nameOrUuid: string) => void` | Triggers a Spline event associated to an object with provided name or uuid |
| `emitEventReverse` | `(eventName: SplineEventName, nameOrUuid: string) => void` | Triggers a Spline event associated to an object with provided uuid in reverse order. Starts from last state to first state |
| `findObjectById` | `(uuid: string) => SPEObject` | Searches through scene's children and returns the object with that uuid |
| `findObjectByName` | `(name: string) => SPEObject` | Searches through scene's children and returns the first object with that name |
| `setZoom` | `(zoom: number) => void` | Sets the initial zoom of the scene |
| `getAllObjects` | `() => SPEObject[]` | Returns all objects in the scene (documented separately) |

**Example Usage:**
```typescript
function onLoad(spline: Application) {
  // Find objects
  const helmet = spline.findObjectByName('helmet_for_spline');
  const helmetById = spline.findObjectById('8E8C2DDD-18B6-4C54-861D-7ED2519DE20E');

  // Trigger events
  spline.emitEvent('mouseDown', 'Cube');
  spline.emitEventReverse('mouseHover', helmet.id);

  // Set camera zoom
  spline.setZoom(1.5);

  // Get all objects
  const allObjects = spline.getAllObjects();
}
```

**Notes:**
- `emitEvent` can accept either object **name** (string) or **uuid** (string)
- `emitEventReverse` plays animations backwards (from last state to first)
- `findObjectByName` returns the **first** matching object if duplicates exist
- `setZoom` sets initial zoom level (1.0 = default, >1.0 = zoom in, <1.0 = zoom out)

---

## Object Management

### Finding Objects
**Conventional 3D (Three.js):**
```javascript
scene.getObjectByName('objectName')
scene.getObjectById(id)
```

**Spline Runtime:**
```javascript
// Find by name
const obj = spline.findObjectByName('Cube');

// Find by ID (get ID by right-clicking object ‚Üí Copy Development Object ID)
const obj = spline.findObjectById('8E8C2DDD-18B6-4C54-861D-7ED2519DE20E');

// Get all objects
const allObjects = spline.getAllObjects();
```

### Storing Object References
**Best Practice:** Use React refs to store Spline objects for later manipulation.

```typescript
import { useRef } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const cube = useRef();

  function onLoad(spline) {
    const obj = spline.findObjectByName('Cube');
    // or
    // const obj = spline.findObjectById('8E8C2DDD-18B6-4C54-861D-7ED2519DE20E');

    // save it in a ref for later use
    cube.current = obj;
  }

  function moveObj() {
    console.log(cube.current);
    // Spline Object => { name: 'Cube', id: '8E8C2DDD-18B6-4C54-861D-7ED2519DE20E', position: {}, ... }

    // move the object in 3D space
    cube.current.position.x += 10;
  }

  return (
    <div>
      <Spline
        scene="https://prod.spline.design/6Wq1Q7YGyM-iab9i/scene.splinecode"
        onLoad={onLoad}
      />
      <button type="button" onClick={moveObj}>
        Move Cube
      </button>
    </div>
  );
}
```

**Current Implementation (helmet-customizer):**
```typescript
// From app/page.tsx
const splineRef = useRef<Application>();

function onLoad(spline: Application) {
  splineRef.current = spline;

  // Find helmet
  const helmet = spline.findObjectByName('helmet_for_spline')
              || spline.findObjectByName('Helmet')
              || spline.findObjectByName('helmet');

  // Find other objects
  const football = spline.findObjectByName('Mesh_0')
                || spline.findObjectByName('football')
                || spline.findObjectByName('mesh_0');
}
```

---

## Events

### Listening to Spline Events

You can listen to any Spline Event set in the Events panel of the Spline editor by attaching a listener to the Spline component.

**Available Event Listeners:**
- `onSplineMouseDown` - Mouse button pressed on object
- `onSplineMouseUp` - Mouse button released
- `onSplineMouseHover` - Mouse hovering over object
- `onSplineMouseMove` - Mouse moving
- `onSplineKeyDown` - Keyboard key pressed
- `onSplineKeyUp` - Keyboard key released
- (Additional events configured in Spline Editor ‚Üí Events panel)

**Example:**
```typescript
import Spline from '@splinetool/react-spline';

export default function App() {
  function onSplineMouseDown(e) {
    if (e.target.name === 'Cube') {
      console.log('I have been clicked!');
    }
  }

  return (
    <div>
      <Spline
        scene="https://prod.spline.design/6Wq1Q7YGyM-iab9i/scene.splinecode"
        onSplineMouseDown={onSplineMouseDown}
      />
    </div>
  );
}
```

**Current Implementation (helmet-customizer):**
```typescript
// From app/page.tsx
function onLoad(spline: Application) {
  // Check for available Spline events
  try {
    const splineEvents = spline.getSplineEvents();
    if (splineEvents && Object.keys(splineEvents).length > 0) {
      console.log('üé¨ Available Spline Events:', splineEvents);
    }
  } catch (e) {
    console.log('‚ÑπÔ∏è Spline events not available');
  }

  // Listen to mouseDown events
  spline.addEventListener('mouseDown', (e) => {
    console.log('üñ±Ô∏è Spline mouseDown event:', e.target.name);
  });
}
```

**Note:** Events must be configured in the Spline Editor's Events panel to work. You can also use the runtime `addEventListener()` method for programmatic event handling.

**Reference:** See the [Spline Component Props section](https://github.com/splinetool/react-spline#props) for a complete list of all event listeners.

---

### Triggering Spline Events Programmatically

You can trigger any animation Event you set in the Events panel in the Spline Editor.

There are **two ways** to use `emitEvent()`:

#### Method 1: Via Spline Instance (with object name)
```typescript
import { useRef } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const spline = useRef();

  function onLoad(splineApp) {
    // save the app in a ref for later use
    spline.current = splineApp;
  }

  function triggerAnimation() {
    // Call emitEvent on spline instance, pass object name as second argument
    spline.current.emitEvent('mouseHover', 'Cube');
  }

  return (
    <div>
      <Spline
        scene="https://prod.spline.design/6Wq1Q7YGyM-iab9i/scene.splinecode"
        onLoad={onLoad}
      />
      <button type="button" onClick={triggerAnimation}>
        Trigger Spline Animation
      </button>
    </div>
  );
}
```

#### Method 2: Via Object Reference (no second argument needed)
```typescript
import { useRef } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const objectToAnimate = useRef();

  function onLoad(spline) {
    const obj = spline.findObjectByName('Cube');
    // save the object in a ref for later use
    objectToAnimate.current = obj;
  }

  function triggerAnimation() {
    // Call emitEvent directly on the object (no second argument)
    objectToAnimate.current.emitEvent('mouseHover');
  }

  return (
    <div>
      <Spline
        scene="https://prod.spline.design/6Wq1Q7YGyM-iab9i/scene.splinecode"
        onLoad={onLoad}
      />
      <button type="button" onClick={triggerAnimation}>
        Trigger Spline Animation
      </button>
    </div>
  );
}
```

**API Signatures:**
```typescript
// Method 1: Via spline instance
spline.emitEvent(eventType: string, objectName: string)

// Method 2: Via object reference
object.emitEvent(eventType: string)
```

**Current Implementation (helmet-customizer):**
```typescript
// From app/page.tsx - toggleView function
function toggleView() {
  if (!splineRef.current) return;

  const helmet = splineRef.current.findObjectByName('helmet_for_spline');

  // Attempt to trigger Spline event (Method 1 pattern)
  try {
    if (helmet) {
      splineRef.current.emitEvent('mouseDown', helmet.name);
      console.log('üé¨ Triggered Spline event on helmet');
    }
  } catch (e) {
    console.log('‚ÑπÔ∏è No Spline event configured, using manual control');
  }

  // Manual control fallback
  if (helmet) {
    helmet.visible = !helmet.visible;
  }
}
```

**Best Practice:** Method 2 (via object reference) is preferred when you already have a reference to the object, as it's more direct and doesn't require a name lookup.

**Reference:** See the [Spline Events section](https://github.com/splinetool/react-spline#events) for a complete list of all events you can pass to `emitEvent()`.

---

### Spline Event Types

These are all the Spline event type names that you can pass to the `emitEvent` or `emitEventReverse` functions.

| Event Name | Description |
|------------|-------------|
| `mouseDown` | Refers to the Spline Mouse Down event type |
| `mouseHover` | Refers to the Spline Mouse Hover event type |
| `mouseUp` | Refers to the Spline Mouse Up event type |
| `keyDown` | Refers to the Spline Key Down event type |
| `keyUp` | Refers to the Spline Key Up event type |
| `start` | Refers to the Spline Start event type |
| `lookAt` | Refers to the Spline Look At event type |
| `follow` | Refers to the Spline Follow event type |

**Usage:**
```typescript
// Trigger different event types
spline.emitEvent('mouseDown', 'Cube');
spline.emitEvent('mouseHover', 'helmet_for_spline');
spline.emitEvent('start', 'Animation_Object');
spline.emitEvent('lookAt', 'Camera');

// Play events in reverse
spline.emitEventReverse('mouseDown', 'Cube');
```

**TypeScript Type:**
```typescript
type SplineEventName =
  | 'mouseDown'
  | 'mouseHover'
  | 'mouseUp'
  | 'keyDown'
  | 'keyUp'
  | 'start'
  | 'lookAt'
  | 'follow';
```

**Notes:**
- Events must be configured in the Spline Editor's Events panel
- `start` typically triggers initial animations
- `lookAt` and `follow` are camera-related events
- Use lowercase camelCase (e.g., `mouseDown`, not `MouseDown`)

---

## Webhooks

Webhooks are powerful tools that can trigger actions and update variables in real-time based on external events.

### Webhook Called Event

This event is triggered whenever your webhook receives data from an external source.

**Configuration:**
1. **Select Webhook:** Assign the specific webhook you want to monitor for incoming data
2. **Actions:** Define the actions to execute when the webhook is called

**Possible Actions:**
- Update variables
- Trigger animations
- Initiate other API calls
- Update object properties

---

### Using Variables with Webhooks

Webhook data can be mapped to variables, allowing you to dynamically update and control elements within your Spline project based on real-time data.

#### Set Variables from Webhook Data
Map incoming webhook data to Spline variables:
- **Number variables** - Numeric values (e.g., temperature readings, stock prices)
- **String variables** - Text data (e.g., status messages, names)
- **Boolean variables** - True/false states (e.g., alert status, device on/off)

**Example:**
```typescript
// Webhook sends temperature data
// Map to Number variable in Spline
{
  "temperature": 72.5,
  "status": "normal",
  "alertActive": false
}
```

#### Update Object Properties
Attach variables to object properties so changes in webhook data are immediately reflected in your scene.

**Use Cases:**
- Update text fields with latest information
- Change object colors based on data received
- Modify object positions, scales, or rotations
- Toggle visibility based on boolean values

#### Trigger Actions Based on Variables
Use **Variable Change Events** to trigger specific actions when a webhook updates a variable.

**Example Workflow:**
1. Webhook updates Boolean variable `alertStatus` to `true`
2. Variable Change Event detects the change
3. Triggers animation, sound, or visual alert
4. Changes object state in the scene

---

### Practical Use Cases

#### Real-time Notifications
```typescript
// Slack/Zapier/Custom System ‚Üí Spline
{
  "type": "notification",
  "message": "New order received",
  "priority": "high"
}

// Actions:
// - Display notification in 3D scene
// - Trigger alert animation
// - Update status indicator color
```

#### IoT Integration
```typescript
// Smart Home Device ‚Üí Spline
{
  "deviceType": "temperature_sensor",
  "temperature": 68.2,
  "humidity": 45,
  "motionDetected": true
}

// Actions:
// - Update temperature display
// - Change scene lighting based on conditions
// - Trigger motion animation when detected
```

#### Custom Alerts and Responses
```typescript
// Database/API ‚Üí Spline
{
  "stockPrice": 152.30,
  "threshold": 150.00,
  "alertTriggered": true
}

// Actions:
// - Trigger visual alert when threshold met
// - Play sound notification
// - Update price display
// - Animate graph or chart
```

#### Live Dashboard Integration
```typescript
// Analytics API ‚Üí Spline
{
  "activeUsers": 1250,
  "revenue": 45000,
  "conversionRate": 3.2
}

// Actions:
// - Update 3D charts/graphs
// - Animate counters
// - Change colors based on performance
```

---

### Best Practices

#### 1. Test Your Webhook
- Ensure webhook is correctly configured before deploying to production
- Verify data is being received and processed correctly
- Test all possible data scenarios (success, error, edge cases)
- Use webhook testing tools (Postman, webhook.site, etc.)

#### 2. Security
**Required Security Measures:**
- ‚úÖ Always use secure, encrypted connections (HTTPS)
- ‚úÖ Never expose authorization tokens publicly
- ‚úÖ Store credentials securely (environment variables, secrets management)
- ‚úÖ Validate webhook signatures when possible
- ‚úÖ Implement rate limiting to prevent abuse

**Example Secure Setup:**
```typescript
// Store webhook URL securely
const WEBHOOK_URL = process.env.SPLINE_WEBHOOK_URL;

// Validate incoming data
if (!isValidWebhookSignature(request)) {
  return res.status(401).json({ error: 'Unauthorized' });
}
```

#### 3. Debugging
**Debugging Tools:**
- Enable logging for incoming webhook data
- Monitor variable updates in Spline editor
- Use browser DevTools to inspect network requests
- Implement error handling and fallbacks

**Example Debug Workflow:**
```typescript
// Log incoming webhook data
console.log('Webhook received:', {
  timestamp: new Date().toISOString(),
  data: webhookData,
  variables: updatedVariables
});

// Monitor variable changes
spline.addEventListener('variableChange', (e) => {
  console.log('Variable updated:', e.variableName, e.newValue);
});
```

#### 4. Error Handling
```typescript
// Graceful error handling
try {
  const data = await fetchWebhookData();
  updateSplineVariables(data);
} catch (error) {
  console.error('Webhook error:', error);
  // Set fallback values
  setDefaultValues();
}
```

#### 5. Performance Considerations
- Debounce rapid webhook calls to prevent performance issues
- Batch multiple updates when possible
- Cache webhook data when appropriate
- Use `renderOnDemand: true` to optimize rendering

---

### Integration with Spline Runtime

**Setting up webhook-triggered updates in your React app:**

```typescript
import { useRef, useEffect } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const splineRef = useRef();

  useEffect(() => {
    // Listen for webhook data
    const handleWebhookData = async (data) => {
      if (!splineRef.current) return;

      // Find objects to update
      const statusIndicator = splineRef.current.findObjectByName('StatusIndicator');
      const counterText = splineRef.current.findObjectByName('Counter');

      // Update based on webhook data
      if (data.alertActive) {
        statusIndicator.material.color = '#FF0000'; // Red alert
        splineRef.current.emitEvent('start', 'AlertAnimation');
      }

      // Update text or numbers
      if (counterText && data.count) {
        counterText.text = data.count.toString();
      }
    };

    // Subscribe to your webhook service
    // (Implementation depends on your backend)
    const unsubscribe = subscribeToWebhook(handleWebhookData);

    return () => unsubscribe();
  }, []);

  function onLoad(spline) {
    splineRef.current = spline;
    console.log('Spline loaded, ready for webhook data');
  }

  return (
    <Spline
      scene="/scene.splinecode"
      onLoad={onLoad}
    />
  );
}
```

---

## APIs

APIs provide endless possibilities for integrating external services into your Spline projects, enabling you to create highly customized and dynamic experiences.

### Creating a New API Item

**Steps to create an API in Spline Editor:**

1. Navigate to the **Variables & Data Panel** on the right sidebar of Spline editor (accessible when nothing is selected in editor)
2. Click on the **APIs** tab
3. Click on **New API** to create a new API item

---

### Configuring an API

Select the HTTP method for communicating with the API:

| Method | Purpose |
|--------|---------|
| **GET** | Retrieve data from the server |
| **POST** | Send data to the server |
| **DELETE** | Remove data from the server |
| **PUT** | Update/replace data on the server |
| **HEAD** | Retrieve headers only (no body) |
| **OPTIONS** | Describe allowed HTTP methods |
| **PATCH** | Apply partial modifications to data |

**Configuration Options:**

```typescript
{
  method: 'GET' | 'POST' | 'DELETE' | 'PUT' | 'HEAD' | 'OPTIONS' | 'PATCH',
  url: 'https://api.example.com/endpoint',
  requestOnStart: true | false,
  headers: {
    'Authorization': 'Bearer token',
    'Content-Type': 'application/json'
  }
}
```

**API Configuration Fields:**
- **API URL:** The endpoint URL of your API
- **Request on Start:** Whether the API request should automatically start when the scene loads (Yes/No)
- **Headers:** Add necessary headers by entering Key and Value pairs
  - Use the "+" icon to add multiple headers
  - Common headers: Authorization, Content-Type, Accept, etc.

---

### Response Handling

**In Spline Editor:**
- **Preview:** View the API response directly within the Response tab
- **Refresh:** Click the refresh button to retrieve the latest response from the API
- Inspect response structure to map data to variables

**Response Structure Example:**
```json
{
  "temperature": 72.5,
  "condition": "sunny",
  "humidity": 45,
  "windSpeed": 12.3
}
```

---

### API Updated Event

This event triggers when the API receives a response.

**Use Cases:**
- Process data when API call completes
- Update variables with fresh data
- Trigger animations or visual changes
- Handle success/error states

**Example Workflow:**
1. API call completes
2. API Updated Event fires
3. Variables are updated with response data
4. Objects in scene react to new values

---

### API Request Action

You can trigger an API request based on specific events.

**Trigger Events:**
- Scene start
- Mouse click on object
- Mouse hover
- Keyboard input
- Custom events
- Timer-based triggers

**Example:**
```
Event: Mouse Down on "Refresh Button"
Action: API Request ‚Üí Weather API
Result: Latest weather data fetched
```

---

### Using Variables with APIs

When using APIs, the data retrieved can be stored in variables, which can then be used to dynamically update properties within your Spline project.

#### Set Variables from API Response
Map the response data to specific variables:

**Variable Types:**
- **Number** - Numeric values (e.g., temperature: 72.5, score: 100)
- **String** - Text data (e.g., condition: "sunny", status: "active")
- **Boolean** - True/false states (e.g., isRaining: false, alertActive: true)

**Example Mapping:**
```typescript
// API Response
{
  "temperature": 72.5,
  "condition": "sunny",
  "isRaining": false
}

// Variable Mapping
temperatureVar = response.temperature  // Number: 72.5
conditionVar = response.condition      // String: "sunny"
rainingVar = response.isRaining        // Boolean: false
```

#### Update Object Properties
Variables can be attached to object properties such as position, scale, color, or text content.

**Dynamic Updates:**
- Position: Move objects based on API data
- Scale: Resize objects dynamically
- Color: Change colors based on conditions
- Text: Update labels with latest information
- Visibility: Show/hide objects based on boolean values

**Example:**
```
API returns: { "temperature": 72.5 }
Variable: temperatureVar = 72.5
Text Object: Display "72.5¬∞F"
```

#### Trigger Actions Based on Variables
Use **Variable Change Events** to trigger actions when the API updates variables.

**Example Workflow:**
1. API updates String variable with new text
2. Variable Change Event detects the update
3. Automatically update text label in scene
4. Trigger animation or color change

---

### Practical Use Cases

#### Dynamic Weather Display
```typescript
// Weather API Integration
const weatherAPI = {
  method: 'GET',
  url: 'https://api.openweathermap.org/data/2.5/weather?q=London',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY'
  }
}

// API Response
{
  "main": {
    "temp": 72.5,
    "humidity": 45
  },
  "weather": [{
    "main": "Clear",
    "description": "clear sky"
  }],
  "wind": {
    "speed": 12.3
  }
}

// Actions:
// - Store temperature in Number variable
// - Display on 3D text object
// - Use Variable Change Events to modify scene:
//   - Change sky color based on weather
//   - Adjust lighting based on conditions
//   - Animate clouds if cloudy
```

#### Live Scoreboard
```typescript
// Sports API Integration
const sportsAPI = {
  method: 'GET',
  url: 'https://api.sports.com/live/score',
  requestOnStart: true,
  headers: {
    'Content-Type': 'application/json'
  }
}

// API Response
{
  "homeTeam": {
    "name": "Team A",
    "score": 95
  },
  "awayTeam": {
    "name": "Team B",
    "score": 92
  },
  "quarter": 4,
  "timeRemaining": "2:45"
}

// Actions:
// - Update scoreboard in real-time
// - Trigger celebration animation when score changes
// - Flash "NEW SCORE" indicator
// - Update quarter/time displays
```

#### Airtable Integration
```typescript
// Airtable API
const airtableAPI = {
  method: 'GET',
  url: 'https://api.airtable.com/v0/YOUR_BASE/YOUR_TABLE',
  headers: {
    'Authorization': 'Bearer YOUR_AIRTABLE_KEY'
  }
}

// Use Cases:
// - Manage product catalog
// - Display dynamic content
// - Update inventory counts
// - Show real-time availability
```

#### OpenAI Integration
```typescript
// OpenAI API
const openaiAPI = {
  method: 'POST',
  url: 'https://api.openai.com/v1/chat/completions',
  headers: {
    'Authorization': 'Bearer YOUR_OPENAI_KEY',
    'Content-Type': 'application/json'
  },
  body: {
    model: 'gpt-4',
    messages: [{ role: 'user', content: 'Generate a greeting' }]
  }
}

// Use Cases:
// - Generate dynamic text based on AI responses
// - Real-time content updates
// - Interactive chatbot in 3D scene
// - Context-aware responses
```

#### General REST API Integrations
```typescript
// Any REST API
const customAPI = {
  method: 'GET',
  url: 'https://your-api.com/endpoint',
  headers: {
    'Authorization': 'Bearer TOKEN',
    'Custom-Header': 'value'
  }
}

// Possibilities:
// - E-commerce product data
// - User authentication
// - Database queries
// - Third-party services
// - Custom backend integrations
```

---

### Best Practices

#### 1. Testing
**Test Thoroughly:**
- ‚úÖ Test API configuration in Spline Editor preview
- ‚úÖ Verify all response data is correctly mapped
- ‚úÖ Test with different response scenarios (success, error, empty data)
- ‚úÖ Check variable updates are working
- ‚úÖ Validate all event triggers

**Testing Tools:**
- Postman for API testing
- Browser DevTools Network tab
- Spline Editor Response preview
- Console logging for debugging

#### 2. Optimization
**Minimize API Calls:**
- ‚ö†Ô∏è Use `requestOnStart` only when necessary
- ‚ö†Ô∏è Avoid calling APIs on every frame
- ‚ö†Ô∏è Implement caching when appropriate
- ‚ö†Ô∏è Use debouncing for user-triggered requests
- ‚ö†Ô∏è Batch multiple data needs into single request when possible

**Performance Tips:**
```typescript
// Good: Single API call on scene start
requestOnStart: true

// Bad: API call on every mouse move
Event: Mouse Move ‚Üí API Request ‚ùå

// Better: Debounced API call
Event: Button Click ‚Üí API Request (with rate limiting)
```

#### 3. Security ‚ö†Ô∏è CRITICAL

**Never expose sensitive information publicly:**

**‚ùå NEVER DO THIS:**
```typescript
// Exposed in client-side code
const API_KEY = 'sk-1234567890abcdef';  // ‚ùå SECURITY RISK!
```

**‚úÖ DO THIS INSTEAD:**
```typescript
// Use environment variables (server-side)
const API_KEY = process.env.API_KEY;

// Or use a proxy endpoint
const proxyURL = '/api/proxy-endpoint';  // Your server handles auth
```

**Security Checklist:**
- ‚úÖ Store API keys in environment variables
- ‚úÖ Use backend proxy for sensitive APIs
- ‚úÖ Never commit secrets to git
- ‚úÖ Use HTTPS only
- ‚úÖ Implement rate limiting
- ‚úÖ Validate and sanitize all inputs
- ‚úÖ Use read-only keys when possible

**Secure Implementation Example:**
```typescript
// Next.js API Route (server-side)
// /app/api/weather/route.ts
export async function GET(request: Request) {
  const API_KEY = process.env.WEATHER_API_KEY;  // Secure!

  const response = await fetch(
    `https://api.weather.com/data?key=${API_KEY}`
  );

  return Response.json(await response.json());
}

// Spline Configuration (client-side)
const splineAPI = {
  method: 'GET',
  url: '/api/weather',  // Your secure proxy endpoint
  // No API key exposed!
}
```

#### 4. Error Handling
```typescript
// Handle API failures gracefully
try {
  const response = await fetch(apiURL);
  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }
  const data = await response.json();
  updateSplineVariables(data);
} catch (error) {
  console.error('API request failed:', error);
  // Set default/fallback values
  setDefaultValues();
  // Show error state in UI
  showErrorMessage('Unable to fetch data');
}
```

#### 5. Response Validation
```typescript
// Validate API response structure
function validateWeatherResponse(data) {
  if (!data || typeof data.temperature !== 'number') {
    throw new Error('Invalid response format');
  }
  return true;
}
```

---

### Integration with Spline Runtime

**Triggering API calls from your React app:**

```typescript
import { useRef, useEffect, useState } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const splineRef = useRef();
  const [weatherData, setWeatherData] = useState(null);

  // Fetch data from your secure backend
  useEffect(() => {
    const fetchWeather = async () => {
      try {
        const response = await fetch('/api/weather');
        const data = await response.json();
        setWeatherData(data);

        // Update Spline objects with API data
        if (splineRef.current) {
          updateSplineScene(data);
        }
      } catch (error) {
        console.error('Weather fetch failed:', error);
      }
    };

    fetchWeather();
    // Refresh every 5 minutes
    const interval = setInterval(fetchWeather, 5 * 60 * 1000);

    return () => clearInterval(interval);
  }, []);

  function updateSplineScene(data) {
    if (!splineRef.current) return;

    // Find and update objects
    const tempDisplay = splineRef.current.findObjectByName('Temperature');
    const weatherIcon = splineRef.current.findObjectByName('WeatherIcon');

    if (tempDisplay) {
      tempDisplay.text = `${data.temperature}¬∞F`;
    }

    if (weatherIcon && data.condition === 'sunny') {
      weatherIcon.material.color = '#FFD700'; // Gold
      splineRef.current.emitEvent('start', 'SunnyAnimation');
    }
  }

  function onLoad(spline) {
    splineRef.current = spline;

    // Update scene with initial data if available
    if (weatherData) {
      updateSplineScene(weatherData);
    }
  }

  return (
    <div>
      <Spline
        scene="/scene.splinecode"
        onLoad={onLoad}
      />

      <button onClick={() => fetchWeather()}>
        Refresh Weather
      </button>
    </div>
  );
}
```

---

## Variables

Variables enable you to create truly interactive and dynamic experiences in Spline. By leveraging variables along with Variable Change Events and Set Variable Actions, you can craft responsive 3D scenes that react to user input, time, and external data.

### Variable Types

#### Static Variables

**Number Variables**
- Store numeric values (integers, decimals)
- Use for: counters, scores, temperatures, positions, scales
- Example: `scoreValue = 100`, `temperature = 72.5`

**String Variables**
- Store text data
- Use for: labels, messages, status text, names
- Example: `playerName = "John"`, `statusMessage = "Active"`

**Boolean Variables**
- Store true/false states
- Use for: toggles, flags, conditions
- Example: `isActive = true`, `soundEnabled = false`

---

#### Dynamic Variables

**Time Variable**
- Automatically updates with elapsed time
- Use for: animations based on time, clocks, timers
- Updates every frame with current time value

**Counter Variable**
- Increments automatically or on trigger
- Use for: click counters, iteration tracking, scoreboards
- Can be reset, incremented, decremented

**Random Variable**
- Generates random values
- Use for: randomized animations, procedural generation, variety
- Can specify min/max ranges

---

### Creating Variables

**In Spline Editor:**
1. Navigate to **Variables & Data Panel** (right sidebar)
2. Click on **Variables** tab
3. Click **New Variable**
4. Select variable type (Number, String, Boolean, Time, Counter, Random)
5. Configure initial value and settings

**Example Configuration:**
```typescript
// Number Variable
{
  name: 'score',
  type: 'Number',
  initialValue: 0,
  min: 0,
  max: 1000
}

// String Variable
{
  name: 'playerName',
  type: 'String',
  initialValue: 'Player 1'
}

// Boolean Variable
{
  name: 'soundEnabled',
  type: 'Boolean',
  initialValue: true
}

// Time Variable
{
  name: 'elapsedTime',
  type: 'Time',
  startValue: 0
}

// Counter Variable
{
  name: 'clickCount',
  type: 'Counter',
  startValue: 0,
  increment: 1
}

// Random Variable
{
  name: 'randomValue',
  type: 'Random',
  min: 0,
  max: 100
}
```

---

### Attaching Variables to Object Properties

Variables can be dynamically linked to object properties, enabling real-time updates.

#### Attachable Properties:

**Transform Properties:**
- Position (X, Y, Z)
- Scale (X, Y, Z)
- Rotation (X, Y, Z)

**Material Properties:**
- Color
- Opacity
- Metalness
- Roughness

**Text Properties:**
- Text content
- Font size
- Color

**Other Properties:**
- Visibility (Boolean)
- Custom properties

#### Example Attachments:

```typescript
// Position based on variable
Object: Cube
Property: Position Y
Variable: heightValue
// Cube moves up/down as heightValue changes

// Color based on variable
Object: Sphere
Property: Material Color
Variable: temperatureValue
// Sphere color changes based on temperature

// Text content from variable
Object: ScoreText
Property: Text Content
Variable: scoreValue
// Text displays current score

// Visibility toggle
Object: Alert
Property: Visible
Variable: alertActive (Boolean)
// Alert shows/hides based on boolean
```

---

### Variable Change Event

Triggers actions when a variable's value changes.

**Use Cases:**
- Update UI when data changes
- Trigger animations on threshold
- Respond to user interactions
- Sync multiple objects

**Event Configuration:**
```
Event Type: Variable Change
Variable: scoreValue
Condition: When value > 100
Actions:
  - Play celebration animation
  - Change trophy color to gold
  - Emit confetti particles
```

**Example Workflow:**
```typescript
// 1. Variable changes
scoreValue = 150  // Updated by API or user action

// 2. Variable Change Event detects change
if (scoreValue > 100) {
  // 3. Trigger actions
  playAnimation('celebration');
  setColor('trophy', '#FFD700');
  emitParticles('confetti');
}
```

---

### Set Variable Action

Programmatically set variable values in response to events.

**Trigger Sources:**
- Mouse click
- Keyboard input
- Timer
- API response
- Another variable change
- Scene start

**Example Actions:**
```typescript
// On button click
Event: Mouse Down on "IncrementButton"
Action: Set Variable
  Variable: scoreValue
  Operation: Add
  Value: 10

// On timer
Event: Timer (every 1 second)
Action: Set Variable
  Variable: counterValue
  Operation: Increment
  Value: 1

// On API response
Event: API Updated
Action: Set Variable
  Variable: temperatureValue
  Operation: Set
  Value: API.response.temperature
```

---

### Capturing Object and Mouse Properties

Use variables to capture and store object states and mouse interactions.

#### Object Property Capture

**Capture Position:**
```
Event: Object Moved
Action: Set Variable
  Variable: lastPosition
  Value: Object.position
```

**Capture Scale:**
```
Event: Object Scaled
Action: Set Variable
  Variable: objectScale
  Value: Object.scale
```

**Capture Rotation:**
```
Event: Object Rotated
Action: Set Variable
  Variable: rotationAngle
  Value: Object.rotation.y
```

#### Mouse Property Capture

**Mouse Position:**
```
Variable: mouseX (Number)
Variable: mouseY (Number)

Event: Mouse Move
Actions:
  - Set Variable mouseX = Mouse.position.x
  - Set Variable mouseY = Mouse.position.y
```

**Click Count:**
```
Variable: clickCounter (Counter)

Event: Mouse Down
Action: Increment clickCounter
```

**Hover State:**
```
Variable: isHovered (Boolean)

Event: Mouse Hover on Object
Action: Set Variable isHovered = true

Event: Mouse Leave Object
Action: Set Variable isHovered = false
```

---

### Practical Variable Workflows

#### Interactive Counter
```typescript
// Variables
clickCount: Counter (start: 0)
displayText: String

// Events
Event: Mouse Down on "Button"
Actions:
  1. Increment clickCount
  2. Set displayText = "Clicks: " + clickCount
  3. If clickCount > 10:
     - Trigger achievement animation
```

#### Time-based Animation
```typescript
// Variables
elapsedTime: Time
rotationSpeed: Number = 2.0

// Attachment
Object: Spinner
Property: Rotation Y
Expression: elapsedTime * rotationSpeed

// Result: Object spins continuously
```

#### Temperature Display
```typescript
// Variables
temperature: Number (from API)
tempColor: String
tempText: String

// Variable Change Event
Event: temperature changes
Actions:
  If temperature < 32:
    Set tempColor = "#0000FF" (blue)
    Set tempText = "Freezing"
  Else If temperature < 70:
    Set tempColor = "#00FF00" (green)
    Set tempText = "Cool"
  Else:
    Set tempColor = "#FF0000" (red)
    Set tempText = "Hot"

// Attachments
Object: TempDisplay
  - Text Content: tempText
  - Material Color: tempColor
```

#### Random Particle System
```typescript
// Variables
randomX: Random (-10 to 10)
randomY: Random (5 to 15)
randomScale: Random (0.5 to 2.0)

// Event: Button Click "Generate Particle"
Actions:
  1. Create new particle
  2. Set position.x = randomX
  3. Set position.y = randomY
  4. Set scale = randomScale
  5. Play spawn animation
```

#### Progress Bar
```typescript
// Variables
progress: Number (0-100)
progressWidth: Number

// Variable Change Event
Event: progress changes
Action: Set progressWidth = (progress / 100) * 200

// Attachment
Object: ProgressBar
Property: Scale X
Variable: progressWidth
```

---

### Best Practices

#### 1. Naming Conventions
```typescript
// Good: Descriptive names
playerScore
isGameActive
currentTemperature

// Bad: Vague names
var1
x
temp
```

#### 2. Initialize Variables
Always set initial values to prevent undefined behavior:
```typescript
score: Number = 0 (not undefined)
playerName: String = "Player" (not empty)
isActive: Boolean = false (not null)
```

#### 3. Use Appropriate Types
```typescript
// Correct types
age: Number
name: String
isEnabled: Boolean

// Wrong types
age: String = "25"  // Should be Number
isEnabled: Number = 1  // Should be Boolean
```

#### 4. Limit Variable Scope
- Use variables only where needed
- Don't create global variables unnecessarily
- Clean up unused variables

#### 5. Performance Considerations
```typescript
// Good: Update on significant changes
Event: Score increases by 10+
Action: Update display

// Bad: Update every frame
Event: Every frame
Action: Set variable ‚ùå (causes performance issues)
```

---

### Integration with Spline Runtime

**Accessing and modifying variables from React:**

```typescript
import { useRef, useEffect, useState } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const splineRef = useRef();
  const [score, setScore] = useState(0);

  function onLoad(spline) {
    splineRef.current = spline;

    // Listen for variable changes in Spline
    spline.addEventListener('variableChange', (e) => {
      console.log('Variable changed:', e.variableName, e.newValue);

      if (e.variableName === 'score') {
        setScore(e.newValue);
      }
    });
  }

  function incrementScore() {
    const newScore = score + 10;
    setScore(newScore);

    // Update Spline variable programmatically
    if (splineRef.current) {
      // Note: Direct variable manipulation depends on Spline API
      // This is a conceptual example
      updateSplineVariable('score', newScore);
    }
  }

  function updateSplineVariable(name, value) {
    if (!splineRef.current) return;

    // Find objects that display the variable
    const scoreDisplay = splineRef.current.findObjectByName('ScoreText');
    if (scoreDisplay) {
      scoreDisplay.text = `Score: ${value}`;
    }

    // Trigger animations based on thresholds
    if (value > 100) {
      splineRef.current.emitEvent('start', 'CelebrationAnimation');
    }
  }

  return (
    <div>
      <Spline
        scene="/scene.splinecode"
        onLoad={onLoad}
      />

      <div>
        <p>Current Score: {score}</p>
        <button onClick={incrementScore}>
          Add 10 Points
        </button>
      </div>
    </div>
  );
}
```

---

### Local Storage (Persistence)

Variables can be persisted across page reloads using Local Storage.

**Enabling Local Storage for a Variable:**

1. Open the **Variables panel** from the right sidebar
2. Find the variable you want to make persistent
3. Hover over the variable
4. Click the **Local Storage icon** that appears on hover
5. Variable value will now persist between sessions

**Benefits:**
- User preferences saved automatically
- Progress tracking across sessions
- Settings persistence
- Game state preservation

**Reset Persistent Data:**
Use the **Clear Local Storage Action** to reset persistent variables back to their default values.

```typescript
// Example: Reset all stored variables
Event: Button Click "Reset All"
Action: Clear Local Storage

// Result: All variables return to initial values
```

**Use Cases:**
```typescript
// User Preferences
Variable: volume (Number) - Persistent
Variable: theme (String) - Persistent
Variable: language (String) - Persistent

// Game Progress
Variable: playerLevel (Number) - Persistent
Variable: highScore (Number) - Persistent
Variable: unlockedItems (String) - Persistent
```

---

### Events Supporting Variables

The following events have access to the **Set Variable Action**. When any of these events are performed, a variable can be set to a new value via an expression.

**Complete Event List:**

| Event | Description | Variable Use Case |
|-------|-------------|-------------------|
| **Variable Change Event** | Triggered when a variable's value changes | Chain variable updates |
| **Start Event** | Scene initialization | Set initial values |
| **Mouse Up Event** | Mouse button released | Update click state |
| **Mouse Down Event** | Mouse button pressed | Increment counter |
| **Mouse Hover Event** | Mouse hovering over object | Update hover state |
| **Key Up Event** | Keyboard key released | Reset input state |
| **Key Down Event** | Keyboard key pressed | Update input value |
| **Key Press Event** | Keyboard key pressed (continuous) | Accumulate input |
| **Scroll Event** | Mouse wheel scroll | Update scroll position |
| **Drag and Drop Event** | Object dragged and dropped | Update position |
| **Distance Event** | Distance threshold reached | Proximity detection |
| **State Change Event** | Object state changes | Update UI state |
| **Collision Event** | Objects collide | Update collision count |
| **Trigger Area Event** | Object enters trigger zone | Area detection |

**High-Level Concepts:**

**Variable Change Event** ‚≠ê
- Special event triggered when a variable's value changes
- **Pro Tip:** Use with dynamic variables (e.g., Counter) to animate object properties
- Enables reactive programming patterns

**Set Variable Action** ‚≠ê
- Modify variables and object properties
- Can reference another variable
- Can use custom calculations/expressions

---

### How to Use Variables - Step-by-Step Guide

#### Step 1: Create Variables

1. Open the **Variable Table** from the right sidebar (visible when no objects are selected)
2. Select a variable type (e.g., **"Number"**)
3. Change the number to a specific value (e.g., `100`)
4. Double-click the variable name to rename it (e.g., `Initial Position`)
5. Right-click the variable and select **"Duplicate"**
6. Rename the duplicate (e.g., `New Position`) and adjust its value (e.g., `200`)

**Result:** You now have two variables ready to use!

```typescript
// Created Variables:
Initial Position: Number = 100
New Position: Number = 200
```

---

#### Step 2: Assign a Variable to an Object

1. Create a **Cube** (select it in the top toolbar and click on the viewport)
2. Select the cube
3. Hover over any property (e.g., **Position X**)
4. Click the **little dot** in the upper right corner
5. Select the variable to assign (e.g., `Initial Position`)

**Result:** The object's Position X is now driven by the `Initial Position` variable!

```typescript
// Before:
Cube.position.x = 0 (static value)

// After:
Cube.position.x = Initial Position (100) (dynamic, driven by variable)
```

---

#### Step 3: Update Variables with Events and Actions

Variables can be updated with all sorts of events and actions. Here's a simple example using a mouse click.

**Configuration:**
1. Select the cube
2. Add an event in the right sidebar (Events section)
3. Open the **"Start"** event by clicking on it
4. Change the event type in the top dropdown to **"Mouse Down"**
5. Add an action **"Set Variable"**
6. Expand the action by clicking the **">"** icon
7. Select the variable to change (e.g., `Initial Position`)
8. In the **"To"** section, click **"Add expression"** field
9. Select the `New Position` variable
10. Enter **Play mode** and click on the cube

**Result:** Clicking the cube updates `Initial Position` to `New Position` (200), moving the cube!

**Event Flow:**
```typescript
// Initial State
Initial Position = 100
Cube.position.x = 100

// After Mouse Down Event
Event: Mouse Down on Cube
Action: Set Variable
  Variable: Initial Position
  To: New Position (200)

// Updated State
Initial Position = 200
Cube.position.x = 200 (cube moves!)
```

---

### Advanced Variable Patterns

#### Conditional Updates
```typescript
// Variable Change Event with Conditions
Event: Variable Change (temperature)
Condition: If temperature > 80
Actions:
  Set Variable: alertActive = true
  Set Variable: alertColor = "#FF0000"
```

#### Calculated Expressions
```typescript
// Set Variable with calculation
Event: Mouse Down
Action: Set Variable
  Variable: totalScore
  To: baseScore + bonusPoints * multiplier
```

#### Chained Variables
```typescript
// Variable Change Event triggers another variable
Event: Variable Change (playerLevel)
Action: Set Variable
  Variable: maxHealth
  To: 100 + (playerLevel * 10)

Event: Variable Change (maxHealth)
Action: Set Variable
  Variable: currentHealth
  To: maxHealth
```

---

### Best Practices and Troubleshooting

#### Best Practices

**1. Keep It Simple**
- Start with a few variables
- Build complexity gradually
- Test each variable independently
- Document variable purposes

**2. Test and Iterate**
- Experiment with different values
- Test edge cases (min/max values)
- Verify all event triggers
- Check variable updates in real-time

**3. Naming Conventions**
```typescript
// Good names (clear purpose)
playerHealth
currentScore
isGameActive

// Bad names (unclear)
var1
temp
x
```

**4. Organize Variables**
- Group related variables
- Use consistent naming patterns
- Delete unused variables
- Comment complex calculations

---

#### Troubleshooting

**‚ùå Variable Not Updating?**

**Check:**
- ‚úÖ Variable Change events are correctly configured
- ‚úÖ Set Variable actions reference the right variable
- ‚úÖ Formula/expression is valid
- ‚úÖ Event is actually triggering (add console.log)
- ‚úÖ Variable type matches expected value

**Fix:**
```typescript
// Debug variable updates
Event: Mouse Down
Actions:
  1. Set Variable (your variable)
  2. Log to console: "Variable updated to: " + yourVariable
```

**‚ùå Unexpected Behavior?**

**Check:**
- ‚úÖ Logic flow is correct
- ‚úÖ No variable name conflicts
- ‚úÖ Initial values are set properly
- ‚úÖ Event order is correct
- ‚úÖ No circular dependencies

**Common Issues:**
```typescript
// Issue: Circular dependency
Variable A depends on Variable B
Variable B depends on Variable A
‚ùå This creates an infinite loop!

// Solution: Break the dependency
Use intermediate variable or different logic flow
```

**‚ùå Performance Issues?**

**Check:**
- ‚ö†Ô∏è Not updating variables every frame
- ‚ö†Ô∏è Not creating too many variables (use sparingly)
- ‚ö†Ô∏è Not using complex calculations in real-time events
- ‚ö†Ô∏è Using Local Storage appropriately (not overusing)

**Optimization:**
```typescript
// Bad: Update every frame
Event: Every Frame
Action: Set Variable ‚ùå

// Good: Update on significant changes
Event: Mouse Down
Action: Set Variable ‚úÖ

// Better: Debounced updates
Event: Mouse Down (with 100ms delay)
Action: Set Variable ‚úÖ
```

**‚ùå Local Storage Not Working?**

**Check:**
- ‚úÖ Local Storage icon is enabled for variable
- ‚úÖ Browser allows Local Storage (not in private mode)
- ‚úÖ No browser storage limit exceeded
- ‚úÖ Variable name hasn't changed

**‚ùå Expression/Formula Errors?**

**Check:**
- ‚úÖ Syntax is correct
- ‚úÖ All referenced variables exist
- ‚úÖ Math operations are valid
- ‚úÖ Type compatibility (Number + String issues)

**Valid Expressions:**
```typescript
// Math operations
value + 10
value * 2
(health / maxHealth) * 100

// String concatenation
"Score: " + scoreValue

// Conditional (ternary)
temperature > 80 ? "Hot" : "Cold"
```

---

### Quick Reference Card

**Variable Types:**
- Number, String, Boolean (static)
- Time, Counter, Random (dynamic)

**Key Events:**
- Variable Change (reactive updates)
- Mouse Down/Up/Hover
- Key Down/Up/Press
- Start, Scroll, Collision

**Key Actions:**
- Set Variable (update values)
- Clear Local Storage (reset persistence)

**Attachment Points:**
- Transform (Position, Scale, Rotation)
- Material (Color, Opacity, Metalness, Roughness)
- Text (Content, Size, Color)
- Visibility (Boolean toggle)

**Summary:**
By leveraging variables, along with Variable Change Events and Set Variable Actions, you can craft truly interactive and dynamic experiences. Explore, experiment, and push the boundaries of creativity with variables in Spline! üöÄ

---

## Performance Metrics & Optimization

Spline provides comprehensive performance metrics to help you optimize your 3D scenes for web delivery.

### Scene Statistics

Access these metrics in the Spline Editor to understand and optimize your scene's performance.

#### File Size & Loading

**Export Size Estimation**
- Estimated file size of exported scene
- Includes all assets, textures, and geometry
- Critical for web performance
- **Target:** Keep under 5MB for optimal loading

**Loading Time Score**
- Calculated score based on scene complexity
- Higher score = faster loading
- Considers file size, polygon count, texture count
- **Goal:** Achieve "Good" or "Excellent" rating

---

#### Geometry Metrics

**Number of Objects**
- Total unique objects in the scene
- Each mesh, light, camera counts as one object
- **Optimization:** Merge similar objects when possible

**Number of Clones**
- Instances of duplicated objects
- Clones are memory-efficient (share geometry)
- **Best Practice:** Use clones instead of duplicating geometry

**Number of Booleans**
- Boolean operations (Union, Subtract, Intersect)
- Can be performance-intensive
- **Optimization:** Minimize boolean operations, bake when possible

**Number of Total Polygons**
- Combined polygon count (objects + clones)
- Most important metric for render performance
- **Targets:**
  - Mobile: < 100K polygons
  - Desktop: < 500K polygons
  - High-end: < 1M polygons

**Number of Object Polygons**
- Polygons from unique objects only
- Excludes cloned geometry
- **Optimization:** Use low-poly models, decimate high-poly meshes

**Number of Cloned Polygons**
- Polygons from cloned instances
- Efficient use of memory
- **Best Practice:** Clone high-poly objects instead of duplicating

---

#### Material & Texture Metrics

**Number of Materials (Non-Assets)**
- Custom materials created in Spline
- Each unique material requires shader compilation
- **Optimization:** Reuse materials across objects

**Number of Materials (Assets)**
- Materials from imported 3D models
- May include PBR textures
- **Optimization:** Consolidate similar materials

**Number of Textures**
- Total texture maps in scene
- Includes: diffuse, normal, roughness, metallic, etc.
- **Optimization:**
  - Compress textures (use JPG for color, PNG for alpha)
  - Reduce texture resolution when possible
  - Atlas multiple textures into single file
- **Targets:**
  - Texture resolution: 1024x1024 or 2048x2048 max
  - Total texture memory: < 50MB

---

#### Lighting & Effects

**Number of Lights**
- Point lights, spotlights, directional lights
- Each light increases render cost
- **Optimization:**
  - Limit to 3-5 lights per scene
  - Use baked lighting when possible
  - Disable shadows on distant lights

**Number of Post-processing Effects**
- Bloom, depth of field, ambient occlusion, etc.
- Significant performance impact
- **Optimization:**
  - Use effects sparingly
  - Disable on mobile devices
  - Test performance with each effect

**Number of Audio Assets**
- Audio files in the scene
- Contributes to download size
- **Optimization:**
  - Compress audio (use MP3)
  - Limit file sizes
  - Load audio on-demand when possible

---

### Performance Optimization Guide

#### Level 1: Critical (Must Do)

**Reduce Polygon Count**
```typescript
// Check polygon count
Total Polygons: 450,000 ‚ùå Too high!

// Actions:
1. Decimate high-poly meshes
2. Use low-poly models for distant objects
3. Remove hidden faces
4. Simplify geometry where detail isn't visible

// Result:
Total Polygons: 150,000 ‚úÖ Optimized!
```



// After
Texture 1: 2048x2048 JPG (1MB) ‚úÖ
Texture 2: 1024x1024 JPG (0.5MB) ‚úÖ
Texture 3: 1024x1024 JPG (0.4MB) ‚úÖ
Total: 1.9MB (87% reduction!)
```

**Reduce Draw Calls**
```typescript
// Before: 50 unique objects
Objects: 50
Materials: 50
Draw Calls: ~50

// After: Merge objects with same material
Objects: 15 (merged)
Materials: 15
Draw Calls: ~15 (70% reduction)
```

---

#### Level 2: Important (Should Do)

**Use Clones Efficiently**
```typescript
// Bad: Duplicate high-poly object 100 times
Objects: 100
Total Polygons: 100 √ó 5,000 = 500,000 ‚ùå

// Good: Clone high-poly object 100 times
Objects: 1
Clones: 100
Total Polygons: 5,000 (shared geometry) ‚úÖ
Memory Usage: 95% reduction!
```

**Optimize Lighting**
```typescript
// Before
Lights: 12 (all casting shadows) ‚ùå
Render cost: Very High

// After
Lights: 4 (2 with shadows, 2 without) ‚úÖ
Render cost: Medium

// Best: Baked lighting
Lights: 1 directional + baked ambient ‚úÖ
Render cost: Low
```

**Limit Post-Processing**
```typescript
// Desktop
Effects: Bloom, SSAO, DOF (2-3 effects max) ‚úÖ

// Mobile
Effects: None or Bloom only ‚úÖ
```

---

#### Level 3: Advanced (Nice to Have)

**LOD (Level of Detail)**
```typescript
// Concept: Swap models based on distance
Distance < 10: High-poly model (10K polygons)
Distance 10-50: Medium-poly model (2K polygons)
Distance > 50: Low-poly model (500 polygons)

// Implementation in Spline Runtime
function updateLOD(camera, object) {
  const distance = getDistance(camera, object);

  if (distance < 10) {
    showObject('highPolyModel');
  } else if (distance < 50) {
    showObject('mediumPolyModel');
  } else {
    showObject('lowPolyModel');
  }
}
```

**Frustum Culling**
```typescript
// Don't render objects outside camera view
// Spline handles this automatically, but you can assist:

// Hide objects that are definitely not visible
if (!isInCameraView(object)) {
  object.visible = false;
}
```

**Lazy Loading**
```typescript
// Load heavy assets only when needed
import React, { lazy, Suspense } from 'react';

const Spline = lazy(() => import('@splinetool/react-spline'));

function App() {
  return (
    <Suspense fallback={<div>Loading 3D scene...</div>}>
      <Spline scene="/scene.splinecode" />
    </Suspense>
  );
}
```

---

### Performance Targets by Platform

#### Mobile Devices
```typescript
Target Metrics:
- Total Polygons: < 100,000
- Textures: 512x512 to 1024x1024
- Materials: < 10
- Lights: 1-2 (no shadows)
- Post-processing: None or minimal
- Export Size: < 2MB
- Loading Time Score: "Good" or better
```

#### Desktop (Standard)
```typescript
Target Metrics:
- Total Polygons: < 500,000
- Textures: 1024x1024 to 2048x2048
- Materials: < 20
- Lights: 3-5 (selective shadows)
- Post-processing: 2-3 effects
- Export Size: < 5MB
- Loading Time Score: "Excellent"
```

#### Desktop (High-End)
```typescript
Target Metrics:
- Total Polygons: < 1,000,000
- Textures: 2048x2048 to 4096x4096
- Materials: < 30
- Lights: 5-8 (with shadows)
- Post-processing: Multiple effects
- Export Size: < 10MB
- Loading Time Score: "Good"
```

---

### Monitoring Performance in Production

**React Integration:**
```typescript
import { useRef, useEffect, useState } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const splineRef = useRef();
  const [loadTime, setLoadTime] = useState(0);
  const [fps, setFps] = useState(60);

  function onLoad(spline) {
    splineRef.current = spline;

    // Measure load time
    const loadEndTime = performance.now();
    setLoadTime(loadEndTime);

    console.log('Scene loaded in:', loadEndTime, 'ms');
  }

  useEffect(() => {
    // Monitor FPS
    let frameCount = 0;
    let lastTime = performance.now();

    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();

      if (currentTime - lastTime >= 1000) {
        setFps(frameCount);
        frameCount = 0;
        lastTime = currentTime;
      }

      requestAnimationFrame(measureFPS);
    };

    measureFPS();
  }, []);

  return (
    <div>
      <Spline
        scene="/scene.splinecode"
        onLoad={onLoad}
      />

      {/* Performance HUD */}
      <div style={{ position: 'fixed', top: 10, right: 10 }}>
        <p>Load Time: {loadTime.toFixed(0)}ms</p>
        <p>FPS: {fps}</p>
      </div>
    </div>
  );
}
```

---

### Optimization Checklist

**Before Publishing:**
- [ ] Total polygons within target range
- [ ] All textures compressed (JPG for color, PNG for alpha)
- [ ] Materials consolidated and reused
- [ ] Clones used instead of duplicates
- [ ] Lighting optimized (3-5 lights max)
- [ ] Post-processing effects limited
- [ ] Export size under 5MB
- [ ] Loading Time Score is "Good" or better
- [ ] Tested on target devices (mobile + desktop)
- [ ] FPS > 30 on target devices

**Production Monitoring:**
- [ ] Analytics tracking load times
- [ ] Error logging for WebGL failures
- [ ] Performance monitoring (FPS, memory)
- [ ] User feedback on performance
- [ ] A/B testing different optimization levels

---

### Quick Reference: Performance Metrics

| Metric | Mobile Target | Desktop Target | Impact |
|--------|---------------|----------------|--------|
| Total Polygons | < 100K | < 500K | üî¥ Critical |
| Export Size | < 2MB | < 5MB | üî¥ Critical |
| Textures | 512-1024 | 1024-2048 | üü° High |
| Materials | < 10 | < 20 | üü° High |
| Lights | 1-2 | 3-5 | üü° High |
| Post-FX | 0-1 | 2-3 | üü¢ Medium |
| Audio Assets | < 1MB | < 5MB | üü¢ Medium |

**Summary:**
By monitoring and optimizing these metrics, you can ensure your Spline scenes deliver excellent performance across all devices! üöÄ

---

### Advanced Performance Metrics

#### Memory Management

**Geometry Memory Usage**
- Memory consumed by vertex data (positions, normals, UVs)
- Each vertex typically uses 32-48 bytes
- **Calculation:** `vertexCount √ó 40 bytes ‚âà geometry memory`
- **Optimization:**
  - Remove unused vertex attributes
  - Use indexed geometry (share vertices)
  - Merge duplicate vertices

**Texture Memory Usage**
- GPU memory consumed by texture maps
- **Calculation:** `width √ó height √ó bytesPerPixel`
- **Examples:**
  ```typescript
  // 2048√ó2048 RGBA texture
  2048 √ó 2048 √ó 4 bytes = 16.7MB ‚ùå

  // 1024√ó1024 RGB texture (compressed)
  1024 √ó 1024 √ó 3 bytes = 3.1MB ‚úÖ

  // 1024√ó1024 RGB texture (JPG compressed)
  ~500KB (95% reduction!) ‚úÖ
  ```
- **Optimization:**
  - Use power-of-two dimensions (512, 1024, 2048)
  - Enable mipmapping for better quality and performance
  - Use compressed formats (JPG for color, PNG for alpha)
  - Consider texture atlasing

**Material Memory**
- Each material compiles to a shader program
- Shader compilation is expensive
- **Optimization:**
  - Reuse materials across objects
  - Minimize unique material variations
  - Batch objects with same material

**Total Scene Memory**
```typescript
Total Memory = Geometry Memory + Texture Memory + Material Memory + Audio Memory

// Example calculation:
Geometry: 2MB
Textures: 8MB
Materials: 1MB
Audio: 3MB
Total: 14MB

// Targets:
Mobile: < 25MB
Desktop: < 100MB
High-end: < 250MB
```

---

#### Render Performance Metrics

**Draw Calls**
- Number of GPU draw operations per frame
- Most critical metric for real-time performance
- **Each draw call:**
  - Sets up shader
  - Binds textures
  - Uploads uniforms
  - Issues draw command
- **Targets:**
  - Mobile: < 50 draw calls
  - Desktop: < 100 draw calls
  - High-end: < 200 draw calls
- **Optimization:**
  ```typescript
  // Bad: 100 objects, 100 materials = 100 draw calls
  Objects: 100
  Materials: 100 unique
  Draw Calls: 100 ‚ùå

  // Good: 100 objects, 10 materials = 10 draw calls
  Objects: 100
  Materials: 10 (reused)
  Draw Calls: 10 ‚úÖ

  // Best: Instanced rendering (clones)
  Objects: 1
  Clones: 100
  Draw Calls: 1 ‚úÖ
  ```

**Frame Rate (FPS)**
- Frames rendered per second
- **Targets:**
  - Minimum: 30 FPS (acceptable)
  - Good: 60 FPS (smooth)
  - Excellent: 120 FPS (very smooth)
- **Frame Budget:**
  ```typescript
  60 FPS = 16.67ms per frame
  30 FPS = 33.33ms per frame

  Frame Time Breakdown:
  - JavaScript logic: < 5ms
  - Scene graph updates: < 2ms
  - Rendering: < 8ms
  - Browser overhead: < 2ms
  Total: 16.67ms (60 FPS)
  ```

**GPU Utilization**
- Percentage of GPU capacity used
- Monitor via browser DevTools
- **Optimization:**
  - Reduce shader complexity
  - Lower polygon count
  - Disable expensive effects (SSAO, DOF)
  - Reduce shadow quality

**CPU Utilization**
- Percentage of CPU used for scene updates
- **Optimization:**
  - Minimize object updates per frame
  - Use object pooling for frequently created/destroyed objects
  - Debounce expensive calculations
  - Offload to Web Workers when possible

---

#### Network Performance

**Initial Load Time**
- Time from request to scene ready
- **Breakdown:**
  ```typescript
  DNS Lookup: ~50ms
  TCP Connection: ~100ms
  TLS Handshake: ~100ms
  Download Time: file_size / bandwidth
  Parse & Compile: ~200-500ms
  Scene Initialization: ~100-300ms
  ```
- **Targets:**
  - Excellent: < 2 seconds
  - Good: < 5 seconds
  - Acceptable: < 10 seconds

**Time to First Render**
- Time until first frame appears
- Critical for perceived performance
- **Optimization:**
  - Show loading screen immediately
  - Progressive loading (load critical assets first)
  - Render placeholder while loading

**Asset Download Size**
```typescript
// Before optimization
Scene file: 5MB
Textures: 12MB
Audio: 4MB
Total: 21MB ‚ùå
Download time (5 Mbps): 33.6 seconds

// After optimization
Scene file: 1.5MB (compressed)
Textures: 3MB (compressed, resized)
Audio: 1MB (compressed)
Total: 5.5MB ‚úÖ
Download time (5 Mbps): 8.8 seconds (74% faster!)
```

**Bandwidth Efficiency**
- Compression effectiveness
- **Techniques:**
  - Gzip/Brotli compression (server-side)
  - Binary formats (GLB vs GLTF)
  - Lazy loading for non-critical assets
  - CDN delivery

---

#### Animation Performance

**Animation Frame Cost**
- CPU time per animation frame
- Includes:
  - Skeleton updates
  - Morph target updates
  - Transform hierarchy updates
- **Optimization:**
  - Limit simultaneous animations
  - Use lower frame rates for distant animations
  - Disable animations outside viewport

**Skeleton Complexity**
- Number of bones in skeletal animations
- **Targets:**
  - Mobile: < 30 bones
  - Desktop: < 75 bones
  - High-end: < 150 bones

**Morph Targets**
- Vertex animation blend shapes
- Very expensive (GPU and memory)
- **Optimization:**
  - Limit to 4-8 morph targets
  - Reduce vertex count on morphed geometry
  - Use skeletal animation instead when possible

---

#### Shadow Performance

**Shadow Map Resolution**
- Resolution of shadow textures
- **Targets:**
  ```typescript
  Mobile: 512√ó512 or disabled
  Desktop: 1024√ó1024
  High-end: 2048√ó2048
  ```
- **Memory Cost:**
  ```typescript
  512√ó512: 1MB per light
  1024√ó1024: 4MB per light
  2048√ó2048: 16MB per light
  ```

**Shadow Cascades**
- Number of shadow cascade levels
- Improves quality but increases cost
- **Optimization:**
  - Mobile: 1 cascade or disabled
  - Desktop: 2-3 cascades
  - Limit shadow distance

**Shadow Casting Objects**
- Objects that cast shadows
- **Optimization:**
  - Disable shadows on small/distant objects
  - Disable shadows on decorative objects
  - Use baked shadows for static objects

---

### Performance Profiling Tools

#### Browser DevTools

**Chrome DevTools Performance Panel**
```typescript
// How to profile:
1. Open DevTools (F12)
2. Go to Performance tab
3. Click Record
4. Interact with scene
5. Stop recording
6. Analyze:
   - Frame rate drops
   - Long tasks (> 50ms)
   - Rendering bottlenecks
   - JavaScript execution time
```

**Performance Markers**
```typescript
// Add custom markers to your code
performance.mark('scene-load-start');
// ... load scene ...
performance.mark('scene-load-end');

performance.measure(
  'scene-load',
  'scene-load-start',
  'scene-load-end'
);

const measures = performance.getEntriesByName('scene-load');
console.log('Scene load time:', measures[0].duration, 'ms');
```

**Memory Profiling**
```typescript
// Monitor memory usage
function logMemory() {
  if (performance.memory) {
    console.log({
      usedJSHeapSize: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',
      totalJSHeapSize: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',
      jsHeapSizeLimit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB'
    });
  }
}

// Log every 5 seconds
setInterval(logMemory, 5000);
```

**WebGL Inspector**
- Extension for Chrome/Firefox
- Shows:
  - Draw calls per frame
  - Texture usage
  - Shader programs
  - Buffer sizes

---

#### Spline Editor Metrics

**Stats Panel**
- Available in Spline Editor (top-right)
- Shows real-time metrics:
  - FPS
  - Draw calls
  - Polygon count
  - Texture memory

**Export Preview**
- Preview export size before publishing
- Test loading performance
- Verify optimization results

---

#### Custom Performance Monitoring

**FPS Monitor Component**
```typescript
import { useRef, useEffect, useState } from 'react';
import Spline from '@splinetool/react-spline';

function FPSMonitor() {
  const [fps, setFps] = useState(0);
  const [frameTime, setFrameTime] = useState(0);
  const frameCountRef = useRef(0);
  const lastTimeRef = useRef(performance.now());

  useEffect(() => {
    let animationId;

    const measurePerformance = () => {
      frameCountRef.current++;
      const currentTime = performance.now();
      const deltaTime = currentTime - lastTimeRef.current;

      if (deltaTime >= 1000) {
        const currentFPS = Math.round((frameCountRef.current * 1000) / deltaTime);
        const avgFrameTime = deltaTime / frameCountRef.current;

        setFps(currentFPS);
        setFrameTime(avgFrameTime.toFixed(2));

        frameCountRef.current = 0;
        lastTimeRef.current = currentTime;
      }

      animationId = requestAnimationFrame(measurePerformance);
    };

    measurePerformance();

    return () => cancelAnimationFrame(animationId);
  }, []);

  return (
    <div style={{
      position: 'fixed',
      top: 10,
      right: 10,
      background: 'rgba(0,0,0,0.7)',
      color: '#0f0',
      padding: '10px',
      fontFamily: 'monospace',
      fontSize: '12px',
      zIndex: 9999
    }}>
      <div>FPS: {fps}</div>
      <div>Frame Time: {frameTime}ms</div>
      <div style={{ color: fps >= 60 ? '#0f0' : fps >= 30 ? '#ff0' : '#f00' }}>
        Status: {fps >= 60 ? 'Excellent' : fps >= 30 ? 'Good' : 'Poor'}
      </div>
    </div>
  );
}

export default function App() {
  return (
    <>
      <Spline scene="/scene.splinecode" />
      <FPSMonitor />
    </>
  );
}
```

**Load Time Tracker**
```typescript
import { useState } from 'react';
import Spline from '@splinetool/react-spline';

export default function App() {
  const [loadMetrics, setLoadMetrics] = useState(null);
  const loadStartTime = useRef(performance.now());

  function onLoad(spline) {
    const loadEndTime = performance.now();
    const loadDuration = loadEndTime - loadStartTime.current;

    // Get performance navigation timing
    const navTiming = performance.getEntriesByType('navigation')[0];

    setLoadMetrics({
      sceneLoadTime: loadDuration.toFixed(0),
      dnsTime: (navTiming.domainLookupEnd - navTiming.domainLookupStart).toFixed(0),
      tcpTime: (navTiming.connectEnd - navTiming.connectStart).toFixed(0),
      requestTime: (navTiming.responseEnd - navTiming.requestStart).toFixed(0),
      totalLoadTime: navTiming.loadEventEnd.toFixed(0)
    });

    console.log('Performance Metrics:', {
      'Scene Load': loadDuration + 'ms',
      'DNS Lookup': navTiming.domainLookupEnd - navTiming.domainLookupStart + 'ms',
      'TCP Connection': navTiming.connectEnd - navTiming.connectStart + 'ms',
      'Request Time': navTiming.responseEnd - navTiming.requestStart + 'ms'
    });
  }

  return (
    <div>
      <Spline scene="/scene.splinecode" onLoad={onLoad} />

      {loadMetrics && (
        <div style={{ position: 'fixed', bottom: 10, left: 10, background: '#000', color: '#fff', padding: '10px' }}>
          <h3>Load Metrics</h3>
          <p>Scene Load: {loadMetrics.sceneLoadTime}ms</p>
          <p>DNS: {loadMetrics.dnsTime}ms</p>
          <p>TCP: {loadMetrics.tcpTime}ms</p>
          <p>Request: {loadMetrics.requestTime}ms</p>
          <p>Total: {loadMetrics.totalLoadTime}ms</p>
        </div>
      )}
    </div>
  );
}
```

**Memory Monitor**
```typescript
import { useEffect, useState } from 'react';

function MemoryMonitor() {
  const [memory, setMemory] = useState(null);

  useEffect(() => {
    const updateMemory = () => {
      if (performance.memory) {
        setMemory({
          used: (performance.memory.usedJSHeapSize / 1048576).toFixed(1),
          total: (performance.memory.totalJSHeapSize / 1048576).toFixed(1),
          limit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(1),
          percentage: ((performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100).toFixed(1)
        });
      }
    };

    updateMemory();
    const interval = setInterval(updateMemory, 1000);

    return () => clearInterval(interval);
  }, []);

  if (!memory) return null;

  return (
    <div style={{
      position: 'fixed',
      top: 70,
      right: 10,
      background: 'rgba(0,0,0,0.7)',
      color: '#0ff',
      padding: '10px',
      fontFamily: 'monospace',
      fontSize: '12px',
      zIndex: 9999
    }}>
      <div>Memory Usage</div>
      <div>Used: {memory.used} MB</div>
      <div>Total: {memory.total} MB</div>
      <div>Limit: {memory.limit} MB</div>
      <div style={{ color: memory.percentage < 70 ? '#0f0' : memory.percentage < 90 ? '#ff0' : '#f00' }}>
        {memory.percentage}% used
      </div>
    </div>
  );
}
```

---

### Performance Testing Methodology

#### Test Matrix


(Standard phones)
- GPU: Mali-G76, Adreno 618
- RAM: 4-6GB
- Screen: 1080p
- Target: 60 FPS

// High-end Mobile (Flagship phones)
- GPU: Mali-G78, Adreno 730
- RAM: 8-12GB
- Screen: 1440p
- Target: 60 FPS

// Low-end Desktop (Integrated graphics)
- GPU: Intel UHD 620, Vega 7
- RAM: 8GB
- Screen: 1080p
- Target: 30-60 FPS

// Mid-range Desktop (Discrete GPU)
- GPU: GTX 1650, RX 5500
- RAM: 16GB
- Screen: 1080p-1440p
- Target: 60 FPS

// High-end Desktop (Gaming GPU)
- GPU: RTX 3070+, RX 6800+
- RAM: 32GB+
- Screen: 1440p-4K
- Target: 120 FPS
```


**Browser Testing**
```typescript
// Test on major browsers
- Chrome/Edge (Chromium)
- Firefox
- Safari (WebKit)
- Mobile browsers (Chrome Mobile, Safari Mobile)
```

---

#### Automated Performance Testing

**Lighthouse CI Integration**
```javascript
// lighthouse.config.js
module.exports = {
  ci: {
    collect: {
      url: ['http://localhost:3000'],
      numberOfRuns: 3,
    },
    assert: {
      assertions: {
        'first-contentful-paint': ['error', { maxNumericValue: 2000 }],
        'largest-contentful-paint': ['error', { maxNumericValue: 4000 }],
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
        'total-blocking-time': ['error', { maxNumericValue: 300 }],
      },
    },
  },
};
```

**Performance Budget**
```json
{
  "budget": [
    {
      "resourceType": "script",
      "budget": 300
    },
    {
      "resourceType": "image",
      "budget": 500
    },
    {
      "resourceType": "total",
      "budget": 1000
    }
  ]
}
```

---

### Optimization Workflow

#### Step 1: Measure Baseline
```typescript
// Record current metrics
Baseline Metrics:
- Load Time: 8.2s
- FPS: 24
- Draw Calls: 156
- Polygons: 840,000
- Export Size: 12.5MB
- Memory: 185MB
```

#### Step 2: Identify Bottlenecks
```typescript
// Use profiling tools to find issues
Identified Issues:
1. High polygon count (840K > 500K target)
2. Too many draw calls (156 > 100 target)
3. Large textures (4096√ó4096)
4. Too many lights (8 lights with shadows)
```


#### Step 4: Verify Results
```typescript
// Compare to targets
Final Metrics:
- Load Time: 3.1s ‚úÖ (< 5s target)
- FPS: 60 ‚úÖ (60 FPS target)
- Draw Calls: 45 ‚úÖ (< 100 target)
- Polygons: 320K ‚úÖ (< 500K target)
- Export Size: 4.2MB ‚úÖ (< 5MB target)
- Memory: 62MB ‚úÖ (< 100MB target)

Overall improvement:
- 62% faster load time
- 150% better FPS
- 66% smaller file size
```

---

### Mobile-Specific Optimizations

#### Touch Performance
```typescript
// Optimize touch event handling
// Bad: Process every touch move event
canvas.addEventListener('touchmove', (e) => {
  updateScene(e); // Called hundreds of times ‚ùå
});

// Good: Throttle touch events
let lastUpdate = 0;
canvas.addEventListener('touchmove', (e) => {
  const now = performance.now();
  if (now - lastUpdate > 16) { // 60 FPS
    updateScene(e);
    lastUpdate = now;
  }
});
```

#### Battery Optimization
```typescript
// Reduce FPS when battery is low
if ('getBattery' in navigator) {
  navigator.getBattery().then((battery) => {
    if (battery.level < 0.2) {
      // Switch to 30 FPS mode
      setTargetFPS(30);
      disablePostProcessing();
      reduceLightingQuality();
    }
  });
}
```

#### Thermal Throttling
```typescript
// Detect performance degradation
let fpsHistory = [];
const FPS_WINDOW = 60; // Monitor last 60 frames

function checkThermalThrottling() {
  fpsHistory.push(currentFPS);

  if (fpsHistory.length > FPS_WINDOW) {
    fpsHistory.shift();
    const avgFPS = fpsHistory.reduce((a, b) => a + b) / FPS_WINDOW;

    // If FPS dropped significantly
    if (avgFPS < targetFPS * 0.7) {
      console.warn('Thermal throttling detected, reducing quality');
      reduceQuality();
    }
  }
}
```

---

### Real-World Performance Example (helmet-customizer)

**Current Implementation Analysis:**
```typescript
// From helmet-customizer project
Scene Metrics:
- Objects: ~15-20 (helmet parts)
- Materials: ~5-8 (shell, facemask, stripe, etc.)
- Polygons: ~50K-80K (optimized)
- Textures: 1024√ó1024 (compressed)
- Lights: 3 (ambient + 2 directional)
- Export Size: ~2-3MB

Performance Results:
- Desktop: 60 FPS ‚úÖ
- Mobile: 30-45 FPS ‚úÖ
- Load Time: 2-4s ‚úÖ
- Memory: ~45MB ‚úÖ

Optimizations Applied:
1. Used instancing for repeated elements
2. Shared materials across helmet zones
3. Compressed textures to 1024√ó1024
4. Disabled shadows on mobile
5. Lazy-loaded Spline component
6. Implemented renderOnDemand: true
```

**Future Optimization Opportunities:**
```typescript
// Potential improvements for helmet-customizer
1. Implement LOD for distant helmet views
2. Progressive texture loading
3. Texture atlasing for zones
4. Geometry instancing for repeated patterns
5. Pre-compressed GLB format
6. Edge caching via CDN
```

---

### Performance Checklist Summary

**Critical (Must Do):**
- [x] Total polygons < 500K (desktop) / 100K (mobile)
- [x] Export size < 5MB
- [x] Textures compressed (JPG/PNG)
- [x] Draw calls < 100
- [x] FPS ‚â• 30 on target devices

**Important (Should Do):**
- [x] Use clones for repeated geometry
- [x] Limit lights to 3-5
- [x] Optimize shadows (selective/disabled)
- [x] Monitor memory usage < 100MB
- [x] Test on real devices

**Advanced (Nice to Have):**
- [ ] Implement LOD system
- [ ] Progressive loading
- [ ] Texture atlasing
- [ ] Automated performance testing
- [ ] Analytics integration
- [ ] Battery-aware optimization
- [ ] Thermal throttling detection

---

## Material Properties

### Color
**Conventional 3D (Three.js):**
```javascript
material.color.set('#FF0000')
material.emissive.set('#FF0000')
```

**Spline Runtime:**
```javascript
// Add Spline snippets here
```

---

### Material Finish
**Conventional 3D (Three.js):**
```javascript
material.metalness = 0.5
material.roughness = 0.3
```

**Spline Runtime:**
```javascript
// Add Spline snippets here
```

---

## Coordinate Systems

### Axis Orientation
**Three.js Standard:**
- Right-handed coordinate system
- Y-up
- X: right, Y: up, Z: forward (toward camera)

**Spline:**
```
// Add Spline coordinate system info here
```

---

## Code Snippets from Spline Repository

### [Add section title here]
```javascript
// Paste Spline repo snippets here
```

---

## Known Differences & Gotchas

1. **Property Access:**
   - Difference description here

2. **Units:**
   - Rotation: degrees vs radians?
   - Scale: multiplicative vs additive?

3. **Coordinate Systems:**
   - Y-up vs Z-up differences

---

## Current Implementation (helmet-customizer)

### How We Currently Access Spline Objects

From `lib/spline-helmet.ts`:
```typescript
// Finding objects
const objects = findZoneObjects(spline, zone);
const obj = spline.findObjectByName(pattern);

// Setting material properties
typedObj.material.emissive = color;
typedObj.material.emissiveIntensity = 0.7;
typedObj.material.color = color;
typedObj.material.metalness = preset.metalness;
typedObj.material.roughness = preset.roughness;

// Setting camera
camera.position.x = preset.position.x;
camera.position.y = preset.position.y;
camera.position.z = preset.position.z;
camera.rotation.x = preset.rotation.x;
camera.rotation.y = preset.rotation.y;
camera.rotation.z = preset.rotation.z;
```

---

## References

- [Spline Runtime Docs](https://docs.spline.design/)
- [Spline GitHub](https://github.com/splinetool)
- Package: `@splinetool/runtime@1.9.98`
- Package: `@splinetool/react-spline@4.1.0`

---

## Notes

Add any additional observations, tips, or patterns discovered while working with Spline Runtime.
